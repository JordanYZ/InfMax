/*************************************************************************    > File Name: file_2_graph.cpp    > Author: anryyang    > Mail: anryyang@gmail.com     > Created Time: Sat Oct 22 16:02:51 2016 ************************************************************************/#include <iostream>#include <fstream>#include <string>#include<vector>#include "file_2_graph.h"#include <stdio.h>  #include <sys/time.h>#include <time.h> FileToGraph::~FileToGraph(){}void FileToGraph::convert(){    // ifstream infile(file_name);    // string line;    // while (std::getline(infile, line))    // {    //     std::istringstream iss(line);    //     int a, b;    //     if (!(iss >> a >> b)) { break; } // error    //     // process pair (a,b)    // }   ifstream file;// (file_name); ofstream user2File; ofstream graph2File; //int LINES; /*struct outNeigbour { int node; }; vector<int> data;*/ Vertex vertexFile; Users usersFile; Graph graphFile; vector<Edge> edgeNode; Edge edge; vector< vector<int> > vectorData; vector< vector<int> > readData; vector<int> inDegree; int i, j; //char filename[512] = "inFile.txt"; file.open(file_name, ios::in); if (file.fail()) {  cout << "no file." << endl;  file.close(); } else//文件存在   {  //LINES = CountLines(filename);  //int *tempInt = new int[LINES];  //char *tempChar = new char[LINES];  // int i = 0;  while (!file.eof()) //read data    {   vector<int> neighbours;   //while (i == node && !file.eof())   file >> i;   file >> j;   // cout << i << "\t" << j << endl;   neighbours.push_back(i);   neighbours.push_back(j);   readData.push_back(neighbours);   //vectorData[i].push_back(j);   i = -1;   j = -1;  }  file.close(); //关闭文件         } int node = 0; i = 0; vector<int> neighbours; neighbours.push_back(-2); neighbours.push_back(-2); readData.push_back(neighbours); while (i < readData.size() - 2) {  vector<int> index;  while (readData[i][0] == node) {   //cout <<i<<"\t"<<readData[i][0] <<"\t"<<node<<"\t"<< readData[i][1] << "\t";   index.push_back(readData[i][1]);   i = i + 1;  }  //cout << endl;  /*for (j = 0; j < index.size(); j++) {  cout << index[j] <<"\t";  }  cout << endl*/;  //if (index.size)  vectorData.push_back(index);  node++; } inDegree.resize(vectorData.size()); //cout << vectorData.size() << endl; for (i = 0; i < vectorData.size(); i++) { //输出数组内容    //cout << i << "\t" << vectorData[i].size() << "\t";  for (j = 0; j < vectorData[i].size(); j++) {   inDegree[vectorData[i][j]]++;   //cout << vectorData[i][j] << "\t";  }  cout << endl; } user2File.open("user.txt"); graph2File.open("graph.txt"); for (i = 0; i < vectorData.size(); i++) {  //cout << inDegree[j] << "\t";  vertexFile.id = i;  vertexFile.activation_threshhold = 0.5;    vertexFile.opinion = get_opinion();  vertexFile.activation_status = false;  vertexFile.in_degree = inDegree[i];  vertexFile.out_degree = vectorData[i].size();  user2File << vertexFile.id << "\t" << vertexFile.activation_threshhold << "\t" << vertexFile.opinion << "\t" << vertexFile.activation_status << "\t" << vertexFile.in_degree << "\t" << vertexFile.out_degree << endl;  usersFile.push_back(vertexFile);  for (j = 0; j < vectorData[i].size(); j++) {   edge.from = i;   edge.to = vectorData[i][j];   edge.weight = get_weight();   edgeNode.push_back(edge);   graph2File << edge.from << "\t" << edge.to << "\t" << edge.weight << endl;  }  graphFile.push_back(edgeNode);   }  user2File.close(); graph2File.close();}void FileToGraph::get_graph(Graph &g){   // g = graph;   //ifstream file;// (file_name);   //ofstream user2File; ifstream file;// Vertex vertexFile;// Users usersFile; Graph graphFile; vector<Edge> edgeNode; Edge edge; //vector< vector<int> > vectorData;  vector<Edge>   readData; //vector<int> inDegree; int i, j; double weight; char filename[512] = "graph.txt"; file.open(filename, ios::in); if (file.fail()) {  cout << "no file." << endl;  file.close(); } else//文件存在   {  //LINES = CountLines(filename);  //int *tempInt = new int[LINES];  //char *tempChar = new char[LINES];  // int i = 0;  while (!file.eof()) //read data    {   Edge neighbours;   //while (i == node && !file.eof())   file >> i;   file >> j;   file >> weight;   // cout << i << "\t" << j << endl;   neighbours.from = i;   neighbours.to = j;   neighbours.weight = weight;   readData.push_back(neighbours);   //vectorData[i].push_back(j);   i = -1;   j = -1;   weight = -2;  }  file.close(); //关闭文件   } int node = 0; i = 0; Edge neighbours; //neighbours.push_back(-2); //neighbours.push_back(-2); //readData.push_back(neighbours); neighbours.from = -2; neighbours.to = -2; neighbours.weight = -2; readData.push_back(neighbours); while (i < readData.size() - 2) {  vector<Edge> index;  while (readData[i].from == node) {   //cout <<i<<"\t"<<readData[i][0] <<"\t"<<node<<"\t"<< readData[i][1] << "\t";   edge.from = node;   edge.to = readData[i].to;   edge.weight=readData[i].weight;      index.push_back(edge);   i = i + 1;  }  //cout << endl;  /*for (j = 0; j < index.size(); j++) {  cout << index[j] <<"\t";  }  cout << endl*/;  //if (index.size)  graphFile.push_back(index);  node++; } //inDegree.resize(vectorData.size()); //cout << vectorData.size() << endl; g = graphFile;  //for (i = 0; i < graph.size(); i++) { //输出数组内容   // cout << i << "\t" << graph.size() << "\t"; // for (j = 0; j < graph[i].size(); j++) { //  //inDegree[vectorData[i][j]]++; //  cout << graph[i][j].from << "\t" << graph[i][j].to << "\t" << graph[i][j].weight << endl; // } // ///cout << endl; //} //getchar();}void FileToGraph::get_users(Users &u){   ifstream file;  Vertex vertexFile;  Users usersFile; //Graph graphFile; //vector<Edge> edgeNode; //Edge edge; //vector< vector<int> > vectorData; //vector<Edge>   readData; //vector<int> inDegree; int id; double ther; double op; bool as; int in; int out; //double weight; char filename[512] = "user.txt"; file.open(filename, ios::in); if (file.fail()) {  cout << "no file." << endl;  file.close(); } else//文件存在   {   while (!file.eof()) //read data    {   Vertex neighbours;   //while (i == node && !file.eof())   file >> id;   file >> ther;   file >> op;   file >> as;   file >> in;   file >> out;   // cout << i << "\t" << j << endl;   neighbours.id = id;   neighbours.activation_threshhold = ther;   neighbours.opinion = op;   neighbours.activation_status = as;   neighbours.in_degree = in;   neighbours.out_degree = out;   usersFile.push_back(neighbours);   //vectorData[i].push_back(j);  /* i = -1;   j = -1;   weight = -2;*/  }  file.close(); //关闭文件   } //int node = 0; //i = 0; //Edge neighbours; ////neighbours.push_back(-2); ////neighbours.push_back(-2); ////readData.push_back(neighbours); //neighbours.from = -2; //neighbours.to = -2; //neighbours.weight = -2; //readData.push_back(neighbours); //while (i < readData.size() - 2) { // vector<Edge> index; // while (readData[i].from == node) { //  //cout <<i<<"\t"<<readData[i][0] <<"\t"<<node<<"\t"<< readData[i][1] << "\t"; //  edge.from = node; //  edge.to = readData[i].to; //  edge.weight = readData[i].weight; //  index.push_back(edge); //  i = i + 1; // } // //cout << endl; // /*for (j = 0; j < index.size(); j++) { // cout << index[j] <<"\t"; // } // cout << endl*/; // //if (index.size) // graphFile.push_back(index); // node++; //} ////inDegree.resize(vectorData.size()); ////cout << vectorData.size() << endl; //g = graphFile; //for (i = 0; i < graph.size(); i++) { //输出数组内容   // cout << i << "\t" << graph.size() << "\t"; // for (j = 0; j < graph[i].size(); j++) { //  //inDegree[vectorData[i][j]]++; //  cout << graph[i][j].from << "\t" << graph[i][j].to << "\t" << graph[i][j].weight << endl; // } // ///cout << endl; //} //getchar(); usersFile.pop_back(); u = usersFile; /*int i; for (i = 0; i < u.size(); i++) {     cout<< u[i].id << "\t" << u[i].activation_threshhold << "\t" << u[i].opinion << "\t" << u[i].activation_status << "\t" << u[i].in_degree << "\t" << u[i].out_degree << endl; }*/}double FileToGraph::get_weight(){   struct timeval t_val;    gettimeofday(&t_val, NULL);   srand((unsigned)t_val.tv_usec);    double weight = rand()/(double)(RAND_MAX);//(rand()%1000)*0.01;    return weight;}double FileToGraph::get_opinion(){   struct timeval t_val;   gettimeofday(&t_val, NULL);   srand((unsigned)t_val.tv_usec);    double opinion = rand()/(double)(RAND_MAX);//(rand()%1000)*0.01;    return opinion;}int main(){ Graph graph; int i, j; Users user;    FileToGraph f2g("inFile.txt"); f2g.convert(); f2g.get_graph(graph); f2g.get_users(user);   // for(int i=0;i<100;i++){     //   cout<<f2g.get_weight()<<" "<<f2g.get_opinion()<<endl;    //} //cout << graph.size() << endl; //for (i = 0; i < graph.size(); i++) { //输出数组内容   // cout << i << "\t" << graph.size() << "\t"; // for (j = 0; j < graph[i].size(); j++) { //  //inDegree[vectorData[i][j]]++; //  cout << graph[i][j].from << "\t" << graph[i][j].to << "\t" << graph[i][j].weight << endl; // } // ///cout << endl; //}// int i; /*for (i = 0; i < user.size(); i++) {  cout << user[i].id << "\t" << user[i].activation_threshhold << "\t" << user[i].opinion << "\t" << user[i].activation_status << "\t" << user[i].in_degree << "\t" << user[i].out_degree << endl; }*/ getchar();    return 0;}
